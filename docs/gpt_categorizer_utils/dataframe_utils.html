<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gpt_categorizer_utils.dataframe_utils API documentation</title>
<meta name="description" content="Utilities for building a DataFrame of categorized open-ended survey responses based on a codeframe â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gpt_categorizer_utils.dataframe_utils</code></h1>
</header>
<section id="section-intro">
<p>Utilities for building a DataFrame of categorized open-ended survey responses based on a codeframe.</p>
<p>It is designed with an output format in mind that is suitable for data analysis.
It expects the input data to have a column for uuids, and then subsequent columns for responses.</p>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="gpt_categorizer_utils.dataframe_utils.construct_default_categorized_dataframe" href="#gpt_categorizer_utils.dataframe_utils.construct_default_categorized_dataframe">construct_default_categorized_dataframe()</a></code>: Initializes a DataFrame with category columns for each specified response column, setting all entries to 0 except for "Uncategorized" which are set to 1.</li>
<li><code><a title="gpt_categorizer_utils.dataframe_utils.categorize_missing_data_for_response_column" href="#gpt_categorizer_utils.dataframe_utils.categorize_missing_data_for_response_column">categorize_missing_data_for_response_column()</a></code>: Marks category columns as missing (pd.NA) for rows where the corresponding response column has missing data. Expects the category columns to be Int64 type to support pd.NA.</li>
<li><code><a title="gpt_categorizer_utils.dataframe_utils.categorize_responses_for_response_column" href="#gpt_categorizer_utils.dataframe_utils.categorize_responses_for_response_column">categorize_responses_for_response_column()</a></code>: Categorizes responses in a response column by setting the corresponding category columns to 1 and the 'Uncategorized' column to 0 for matched responses.</li>
</ul>
<p>Author: Louie Atkins-Turkish (louie@tapestryresearch.com)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utilities for building a DataFrame of categorized open-ended survey responses based on a codeframe.

It is designed with an output format in mind that is suitable for data analysis.
It expects the input data to have a column for uuids, and then subsequent columns for responses.

Functions:
    - `construct_default_categorized_dataframe`: Initializes a DataFrame with category columns for each specified response column, setting all entries to 0 except for &#34;Uncategorized&#34; which are set to 1.
    - `categorize_missing_data_for_response_column`: Marks category columns as missing (pd.NA) for rows where the corresponding response column has missing data. Expects the category columns to be Int64 type to support pd.NA.
    - `categorize_responses_for_response_column`: Categorizes responses in a response column by setting the corresponding category columns to 1 and the &#39;Uncategorized&#39; column to 0 for matched responses.
    
Author: Louie Atkins-Turkish (louie@tapestryresearch.com)
&#34;&#34;&#34;

import pandas as pd
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


def construct_default_categorized_dataframe(
    categorized_data: pd.DataFrame, response_column_names: list[str], categories_list: list[str]
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Modifies a DataFrame by addingm category columns for each specified response column.

    This function appends columns to the input DataFrame for each combination of response columns and categories.
    Newly added columns are named in the format &#34;{category}_{response_column}&#34;.

    All entries are initialized to 0, except for those under the &#34;Uncategorized&#34; category, which are initialized to 1.

    Args:
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the columns specified in response_column_names.
        response_column_names (list[str]): The names of columns in categorized_data containing open-ended text responses.
        categories_list (list[str]): The list of categories for which columns will be added to the DataFrame.

    Returns:
        pd.DataFrame: The DataFrame with added category columns for each response column.
    &#34;&#34;&#34;

    for response_column in response_column_names:
        for category in categories_list:
            col_name = f&#34;{category}_{response_column}&#34;
            if category == &#34;Uncategorized&#34;:
                categorized_data[col_name] = 1
            else:
                categorized_data[col_name] = 0

            # Convert to Int64 to support pd.NA
            categorized_data[col_name] = categorized_data[col_name].astype(&#34;Int64&#34;)

    return categorized_data


def categorize_missing_data_for_response_column(
    categorized_data: pd.DataFrame,
    response_column: str,
    categories_list: list[str],
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Modifies a DataFrame by marking category columns as missing (pd.NA) for rows where the corresponding response column has missing data.

    This function checks the specified response column for missing value (pd.NA) rows, and updates the corresponding category
    columns to pd.NA for those rows. This is done for all categories in categories_list.

    Expects the category columns to be Int64 type to support pd.NA.

    Args:
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the columns specified in response_column.
        response_column (str): The name of the column in categorized_data to check for missing data.
        categories_list (list[str]): The list of categories that have corresponding columns in the categorized_data DataFrame.

    Returns:
        pd.DataFrame: The DataFrame with updated category columns to reflect missing data in the response column.
    &#34;&#34;&#34;

    def _is_missing(value):
        return pd.isna(value)

    # Boolean mask where each row is True if all elements are missing
    missing_data_mask = categorized_data[response_column].map(_is_missing)

    for category in categories_list:
        col_name = f&#34;{category}_{response_column}&#34;
        categorized_data.loc[missing_data_mask, col_name] = pd.NA

    return categorized_data


def categorize_responses_for_response_column(
    response: str,
    categories: list[str] | str,
    response_column: str,
    categorized_data: pd.DataFrame,
    is_multicode: bool,
) -&gt; None:
    &#34;&#34;&#34;
    Categorizes responses in a DataFrame column based on the specified response and categories.

    This function identifies rows in the response_column that match the given response. It then sets the corresponding
    category columns to 1 and the &#39;Uncategorized&#39; column to 0 for those rows.

    If is_multicode is True, multiple category columns can be modified; otherwise, only a single category column is modified.

    Args:
        response (str): The response text to match against in the categorized_data DataFrame&#39;s response_column.
        categories (list[str] | str): The category or categories corresponding to the response. Must be a list if is_multicode is True.
        response_column (str): The name of the column in categorized_data that contains the responses to categorize.
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the response_column.
        is_multicode (bool): If True, allows categorization across multiple category columns. Otherwise, restricts categorization to a single column.

    Note:
        - If a specified category does not exist in the DataFrame, a warning is printed.
        - This function modifies the categorized_data DataFrame in place and does not return a value.
    &#34;&#34;&#34;

    # Boolean mask for rows in response_column containing selected response
    mask = categorized_data[response_column] == response

    def _categorize_response(category):
        col_name = f&#34;{category}_{response_column}&#34;

        if col_name in categorized_data.columns:
            categorized_data.loc[mask, f&#34;Uncategorized_{response_column}&#34;] = 0
            categorized_data.loc[mask, col_name] = 1
        else:
            logging.error(
                f&#34;Unknown category in categories:\n{categories}\nfor response:\n{response}&#34;
            )

    if is_multicode:
        for category in categories:
            _categorize_response(category)

    else:
        _categorize_response(categories)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gpt_categorizer_utils.dataframe_utils.categorize_missing_data_for_response_column"><code class="name flex">
<span>def <span class="ident">categorize_missing_data_for_response_column</span></span>(<span>categorized_data:Â pandas.core.frame.DataFrame, response_column:Â str, categories_list:Â list[str]) â€‘>Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies a DataFrame by marking category columns as missing (pd.NA) for rows where the corresponding response column has missing data.</p>
<p>This function checks the specified response column for missing value (pd.NA) rows, and updates the corresponding category
columns to pd.NA for those rows. This is done for all categories in categories_list.</p>
<p>Expects the category columns to be Int64 type to support pd.NA.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>categorized_data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame to modify. Must include the columns specified in response_column.</dd>
<dt><strong><code>response_column</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column in categorized_data to check for missing data.</dd>
<dt><strong><code>categories_list</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The list of categories that have corresponding columns in the categorized_data DataFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The DataFrame with updated category columns to reflect missing data in the response column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def categorize_missing_data_for_response_column(
    categorized_data: pd.DataFrame,
    response_column: str,
    categories_list: list[str],
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Modifies a DataFrame by marking category columns as missing (pd.NA) for rows where the corresponding response column has missing data.

    This function checks the specified response column for missing value (pd.NA) rows, and updates the corresponding category
    columns to pd.NA for those rows. This is done for all categories in categories_list.

    Expects the category columns to be Int64 type to support pd.NA.

    Args:
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the columns specified in response_column.
        response_column (str): The name of the column in categorized_data to check for missing data.
        categories_list (list[str]): The list of categories that have corresponding columns in the categorized_data DataFrame.

    Returns:
        pd.DataFrame: The DataFrame with updated category columns to reflect missing data in the response column.
    &#34;&#34;&#34;

    def _is_missing(value):
        return pd.isna(value)

    # Boolean mask where each row is True if all elements are missing
    missing_data_mask = categorized_data[response_column].map(_is_missing)

    for category in categories_list:
        col_name = f&#34;{category}_{response_column}&#34;
        categorized_data.loc[missing_data_mask, col_name] = pd.NA

    return categorized_data</code></pre>
</details>
</dd>
<dt id="gpt_categorizer_utils.dataframe_utils.categorize_responses_for_response_column"><code class="name flex">
<span>def <span class="ident">categorize_responses_for_response_column</span></span>(<span>response:Â str, categories:Â list[str]Â |Â str, response_column:Â str, categorized_data:Â pandas.core.frame.DataFrame, is_multicode:Â bool) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Categorizes responses in a DataFrame column based on the specified response and categories.</p>
<p>This function identifies rows in the response_column that match the given response. It then sets the corresponding
category columns to 1 and the 'Uncategorized' column to 0 for those rows.</p>
<p>If is_multicode is True, multiple category columns can be modified; otherwise, only a single category column is modified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong> :&ensp;<code>str</code></dt>
<dd>The response text to match against in the categorized_data DataFrame's response_column.</dd>
<dt>categories (list[str] | str): The category or categories corresponding to the response. Must be a list if is_multicode is True.</dt>
<dt><strong><code>response_column</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column in categorized_data that contains the responses to categorize.</dd>
<dt><strong><code>categorized_data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame to modify. Must include the response_column.</dd>
<dt><strong><code>is_multicode</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, allows categorization across multiple category columns. Otherwise, restricts categorization to a single column.</dd>
</dl>
<h2 id="note">Note</h2>
<ul>
<li>If a specified category does not exist in the DataFrame, a warning is printed.</li>
<li>This function modifies the categorized_data DataFrame in place and does not return a value.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def categorize_responses_for_response_column(
    response: str,
    categories: list[str] | str,
    response_column: str,
    categorized_data: pd.DataFrame,
    is_multicode: bool,
) -&gt; None:
    &#34;&#34;&#34;
    Categorizes responses in a DataFrame column based on the specified response and categories.

    This function identifies rows in the response_column that match the given response. It then sets the corresponding
    category columns to 1 and the &#39;Uncategorized&#39; column to 0 for those rows.

    If is_multicode is True, multiple category columns can be modified; otherwise, only a single category column is modified.

    Args:
        response (str): The response text to match against in the categorized_data DataFrame&#39;s response_column.
        categories (list[str] | str): The category or categories corresponding to the response. Must be a list if is_multicode is True.
        response_column (str): The name of the column in categorized_data that contains the responses to categorize.
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the response_column.
        is_multicode (bool): If True, allows categorization across multiple category columns. Otherwise, restricts categorization to a single column.

    Note:
        - If a specified category does not exist in the DataFrame, a warning is printed.
        - This function modifies the categorized_data DataFrame in place and does not return a value.
    &#34;&#34;&#34;

    # Boolean mask for rows in response_column containing selected response
    mask = categorized_data[response_column] == response

    def _categorize_response(category):
        col_name = f&#34;{category}_{response_column}&#34;

        if col_name in categorized_data.columns:
            categorized_data.loc[mask, f&#34;Uncategorized_{response_column}&#34;] = 0
            categorized_data.loc[mask, col_name] = 1
        else:
            logging.error(
                f&#34;Unknown category in categories:\n{categories}\nfor response:\n{response}&#34;
            )

    if is_multicode:
        for category in categories:
            _categorize_response(category)

    else:
        _categorize_response(categories)</code></pre>
</details>
</dd>
<dt id="gpt_categorizer_utils.dataframe_utils.construct_default_categorized_dataframe"><code class="name flex">
<span>def <span class="ident">construct_default_categorized_dataframe</span></span>(<span>categorized_data:Â pandas.core.frame.DataFrame, response_column_names:Â list[str], categories_list:Â list[str]) â€‘>Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies a DataFrame by addingm category columns for each specified response column.</p>
<p>This function appends columns to the input DataFrame for each combination of response columns and categories.
Newly added columns are named in the format "{category}_{response_column}".</p>
<p>All entries are initialized to 0, except for those under the "Uncategorized" category, which are initialized to 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>categorized_data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame to modify. Must include the columns specified in response_column_names.</dd>
<dt><strong><code>response_column_names</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The names of columns in categorized_data containing open-ended text responses.</dd>
<dt><strong><code>categories_list</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The list of categories for which columns will be added to the DataFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The DataFrame with added category columns for each response column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_default_categorized_dataframe(
    categorized_data: pd.DataFrame, response_column_names: list[str], categories_list: list[str]
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Modifies a DataFrame by addingm category columns for each specified response column.

    This function appends columns to the input DataFrame for each combination of response columns and categories.
    Newly added columns are named in the format &#34;{category}_{response_column}&#34;.

    All entries are initialized to 0, except for those under the &#34;Uncategorized&#34; category, which are initialized to 1.

    Args:
        categorized_data (pd.DataFrame): The DataFrame to modify. Must include the columns specified in response_column_names.
        response_column_names (list[str]): The names of columns in categorized_data containing open-ended text responses.
        categories_list (list[str]): The list of categories for which columns will be added to the DataFrame.

    Returns:
        pd.DataFrame: The DataFrame with added category columns for each response column.
    &#34;&#34;&#34;

    for response_column in response_column_names:
        for category in categories_list:
            col_name = f&#34;{category}_{response_column}&#34;
            if category == &#34;Uncategorized&#34;:
                categorized_data[col_name] = 1
            else:
                categorized_data[col_name] = 0

            # Convert to Int64 to support pd.NA
            categorized_data[col_name] = categorized_data[col_name].astype(&#34;Int64&#34;)

    return categorized_data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gpt_categorizer_utils" href="index.html">gpt_categorizer_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gpt_categorizer_utils.dataframe_utils.categorize_missing_data_for_response_column" href="#gpt_categorizer_utils.dataframe_utils.categorize_missing_data_for_response_column">categorize_missing_data_for_response_column</a></code></li>
<li><code><a title="gpt_categorizer_utils.dataframe_utils.categorize_responses_for_response_column" href="#gpt_categorizer_utils.dataframe_utils.categorize_responses_for_response_column">categorize_responses_for_response_column</a></code></li>
<li><code><a title="gpt_categorizer_utils.dataframe_utils.construct_default_categorized_dataframe" href="#gpt_categorizer_utils.dataframe_utils.construct_default_categorized_dataframe">construct_default_categorized_dataframe</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>